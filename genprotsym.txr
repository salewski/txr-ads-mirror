@(bind pp-sym-of-file @(hash :equal-based))
@(bind pp-syms-of-sym @(hash :equal-based))
@(next "Makefile")
@(repeat)
@  (cases)
OBJS-$(have_@sym) += @file.o
@    (bind ppsym @(upcase-str `HAVE_@sym`))
@  (or)
OBJS-$(@sym) += @file.o
@    (bind ppsym @(upcase-str `CONFIG_@sym`))
@  (end)
@  (do (set [pp-sym-of-file `@file.c`] ppsym))
@(end)
@(next (open-command "git ls-files ':(glob)*.c'"))
@(bind pp-stack nil)
@(collect)
@file
@  (require (nequal file "protsym.c"))
@  (set pp-stack nil)
@  (next file)
@  (do (whenlet ((pp [pp-sym-of-file file]))
         (set pp-stack (list pp))))
@  (collect :vars ((sym nil)))
@    (cases)
val @(coll)@{sym /[A-Za-z0-9_]+_[sk]/}@/[,;]/@\
           @(do (set [pp-syms-of-sym sym] pp-stack))@(end)
@    (or)
#if @ppsym1 || @ppsym2
@      (do (push `(@ppsym1 || @ppsym2)` pp-stack))
@    (or)
#if @ppsym
@      (do (push ppsym pp-stack))
@    (or)
#elif @ppsym1 || @ppsym2
@      (do (pop pp-stack)
           (push `(@ppsym1 || @ppsym2)` pp-stack))
@    (or)
#elif @ppsym
@      (do (pop pp-stack)
           (push ppsym pp-stack))
@    (or)
#endif
@      (do (pop pp-stack))
@    (end)
@  (end)
@  (flatten sym)
@(end)
@(next "lib.c")
@(collect)
@copyright
@(until)

@(end)
@(flatten sym)
@(bind pp-groups @[group-by pp-syms-of-sym sym])
@(bind gsym @[mapcar (opip sort (tuples 5)) (hash-values pp-groups)])
@(bind gpp @(hash-keys pp-groups))
@(set (gpp gsym) @(multi-sort (list gpp gsym) [list less]))
@(output "protsym.c")
/* This file is generated by genprotsym.txr */

@{copyright "\n"}

#include <stddef.h>
#include "config.h"
#include "lib.h"

@  (repeat :vars (gpp))
@    (if gpp `#if @{gpp " && "}`)
@    (repeat)
extern val @(rep)@gsym, @(last)@gsym;@(end)
@    (end)
@    (if gpp "#endif")
@  (end)

val *protected_sym[] = {
@  (repeat :vars (gpp))
@    (if gpp `#if @{gpp " && "}`)
@    (repeat)
  @(rep)&@gsym, @(last)&@gsym,@(end)
@    (end)
@    (if gpp "#endif")
@  (end)
  convert(val *, 0)
};
@(end)
